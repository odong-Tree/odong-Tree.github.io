---
layout: post
title: CoreData 이해하기 1 (개념 다지기)
category: iOS
tags: [CoreData]
comments: true
---
>이 글은 공부 중에 작성하는 글입니다.    
>정정이 필요한 내용은 댓글로 알려주시면 감사하겠습니다 :)

<br>

안녕하세요 오동나무입니다.  <br>

오늘은 CoreData에 대해서 정리해보려 합니다. 코드로 작성해보기 보다는 CoreData가 무엇인지에 대해서 먼저 알아보도록 하겠습니다. (코드 작성에 대한 내용은 다음 포스팅에서 작성합니다!) 오늘의 포스팅은 '꼼꼼한 재은씨의 Swift', 야곰, 공식문서 등 복합적인 자료를 토대로 공부한 내용으로 작성합니다.

<br>
<br>

# CoreData
코어 데이터는 애플이 코코아 개발 환경을 통해 제공하는 In-Memory 방식의 **데이터 관리 프레임워크** 입니다. 데이터 베이스와 유사하기 때문에 '코어 데이터는 데이터 베이스이다.'라고 이해할 수도 있지만 **코어 데이터는  데이터 베이스가 아닙니다!!** (이에 대해서는 따로 포스팅할 예정입니다.) 편의상으로 일단은 그냥 애플에서 제공하는 데이터베이스?라고 생각해봅시다. CoreData는 SQLite나 Realm과 같은 Third Party 데이터베이스가 아닌 애플에서 제공하는 First Party라는 점이 특징입니다. 그렇기 때문에 애플이 제공하는 다른 프레임워크나 API들과의 호환성이 더 좋겠지요? <br>

> #### First, Second, Third Party
> - First Party: 하드웨어 생산자가 직접 소프트웨어를 개발
> - Second Party: 하드웨어 생산자인 모기업과 자사간의 관계에서의 소프트웨어 개발자
> - Third Party: 하드웨어 생산자와 직접적인 관계없이 소프트웨어를 개발하는 회사 (Third Party Library는 그 회사에서 만든 라이브러리)  <br>
> 참고: [https://m.blog.naver.com/dktmrorl/221742981904](https://m.blog.naver.com/dktmrorl/221742981904)

<br>

### ✐ Object Graph Manager (객체 그래프 관리자)
CoreData는 객체 그래프 관리자 (Object Graph Manager)라고 하는데요, 처음에는 이해가 잘 안되는 말인 것 같습니다. 객체, 관리자는 알겠는데 그래프는 무엇일까요? <br>

![스크린샷 2021-02-20 오후 8 10 53](https://user-images.githubusercontent.com/73867548/108593583-e4d05500-73b7-11eb-88a2-58f8e5f6e4df.jpg)

그래프는 위 그림처럼 **점과 선으로 표현되는 도형** 으로, Node와 Link를 떠올리면 쉽게 이해할 수 있을 것 같습니다.   <br>

객체지향 프로그래밍에서 객체란 ‘독립적이고 자체적인 생명 주기를  가지면서 속성과 기능으로 이루어진 단위 구성체’를 의미합니다. 코어데이터는 저장할 정보들을 **객체**의 형태로 저장하고 이를 관리한다는 것이지요. 객체 그래프라면 저장하기 위해 만들어진 객체들이 서로 **관계(Relation)** 가 생긴다는 이야기입니다. 예를들어

```swift
// 편의상 init 메서드는 생략합니다.

class Odongnamu {
  var age: Int
  var leaf: Leaf
}

class Leaf {
  var num: Int
  var color: String
}
```

이렇게 Odongnamu가 Leaf를 가지는 것으로 관계가 생기는 것처럼 말입니다. 만약 Odongnamu와 Leaf를 저장하고 있을때, Leaf의 값이 변하게 되면 Leaf과 관계가 맺어진 Odongnamu의 데이터도 변경되어야 겠지요? 이와 같은 작업을 코어데이터가 자동으로 해주는 것입니다! 이제 **객체 그래프 관리자** 라는 말을 이해할 수 있을 것 같네요.

<br>

### ✐ CoreData 타입
CoreData는 내부적으로 SQLite를 사용한다고도 하던데요, 반은 맞고 반은 틀린 말인 것 같습니다. CoreData에는 데이터를  저장하는 4가지 방식이 있는데 이중에 가장 많이 사용되는  것이 SQLite를 사용하는 방식이기 때문입니다. (아래의 내용은 '꼼꼼한 재은씨의 Swift 실전편'의 내용을 정리하여 가져온 것입니다.)

* **NSInmemoryStoreType**       
메모리 기반의 저장소를 사용하는 방식(영구 저장소를 사용하지 않음)으로, 앱을 종료했을 때 데이터가 보존되지 않습니다. 인메모리 저장소 타입은 주로 데이터 객체의 런타임 캐싱에 활용됩니다.
* **NSBinaryStoreType**      
데이터를 단순 바이너리 파일 형식으로 저장하는 방식. 데이터 조회 성능을 개선할 수 있다는 장점이 있지만 저장된 데이터의 크기가 커질수록 바이너리 파일의 크기가 커지고 초기 로딩 시간도 늘어난다는 단점이 있습니다.
* **NSXMLStoreType**       
파일에 데이터를 기록하는 면에서는 바이너리 파일과 유사하지만 바이너리 코드가 아니라 XML 방식으로 데이터를 변환하여 저장하는 방식입니다. 파일에 저장하는 것이기때문에 항상 부분 저장이 아닌 전체 저장되거나 저장되지 않는 원자성을 띕니다. 다른 방식에 비해 처리 속도가 느린 것이 단점이지만 코드 외부에서 직접 열어보고 판독할 수 있기 때문에 프로젝트 초기에 디버깅 및 저장 여부 확인이 필요할 때 많이 사용됩니다. **단, iOS에서는 속도 및 성능의 제약 등으로 인해 사용할 수 없습니다.**
* **NSSQLiteStoreType**      
코어 데이터를 사용할 때 가장 많이 선택하는 영구 저장소 타입으로, 일부만 로딩하기 때문에 메모리에 객체 그래프가 완전히 로딩되어 있지 않을 수 있습니다. 다만 우리가 사용하는 범위에서는 크게 문제되지 않는 수준입니다. iOS 프로젝트에서 코어 데이터가 기본으로 채택하는 방식입니다.

<br>

보통 앱을 배포할 때에는 대량의 데이터를 다루는 상황을 고려하여 SQLite를 저장소로 사용하는 것이 좋지만, 만약 데이터 저장이 매우 빠르고 완벽하게 처리되어야 한다면 데이터 전체를 한 번에  기록하는 바이너리 저장소 타입을 사용하는 것이 유리합니다. <br>

SQLite가 주로 사용되기는 하지만 처리 속도와 원자성의 문제가 발생하기도 합니다. SQLite의 경우 부분적인 업데이트를 수행하여 저장하는 방식때문에 어떤 경우에는 전체를 업데이트하는 바이너리, XML 방식보다 느릴 수 있습니다. 수정해야할 부분을 찾아서 처리하여 업데이트를 진행하게 되기 때문입니다. 또한 부분 업데이트 중 오류가 발생하면 전체 파일에 손상이 생길 수 있습니다. (바이너리 방식은 원자적으로 동작하기 때문에 데이터 손실이나 파일 손상이 발생할 가능성이 적고, 파일 업데이트가 끝날때까지 이전 파일이 삭제되지 않아 더 안전하다고 하네요!)
<br>

#### 그 외 주의할 점: 보안
코어 데이터를 사용할 때 내부에서 생성된 저장소 대신 외부 저장소 위치를 지정하면 외부에서 직접 접근이 가능하기때문에 보안에 위험해질 수 있습니다. 외부에서 저장소 내용을 건드리더라도 코어데이터는 이를 알아차리지 못하기 때문에 위험해질 수 있다고 하네요.

<br>


### ✐ 코어 데이터 구조
코어 데이터는 **다층 구조** 로 이루어진 프레임워크입니다. 그 내부에서는 계층 간의 밀접한 연관성을 가지고 상호작용하며, 결과적으로는 **프로그래머와 영구 저장소를 소통하게 해주는 역할** 을 수행합니다.  

![스크린샷 2021-02-20 오후 9 54 02](https://user-images.githubusercontent.com/73867548/108596100-2d8f0a80-73c6-11eb-91f2-77986adf71d5.jpg)

**1) 관리객체**       
데이터가 저장될 형태의 객체. Entity

**2) 관리객체 모델**     
Xcode에서 프로젝트를 생성하면 모델 모양의 (모델을 구성하는)형태의 파일이 있는데 그 자체를 나타낸다고 보면 됩니다.

**3) 관리객체 컨텍스트**    
중추역할. 코어 데이터에서 메모리 상에 객체를 불러오는 가장 핵심적인 역할을 하는 객체로, 크게는 두 가지 역할을 담당합니다.
- 관리 객체를 담거나 생성, 삭제할 수 있는 만능  상자
- 영구 저장소 및 영구 저장소 코디네이터  (Persistent  Store Coordinator)에 대한 관리자

Persistent  Store Coordinator와 밀접하게 연결되어 있으며, 우리가 요청하는  읽기, 쓰기를 처리합니다. 이 모든 작업은  컨텍스트 내부에서 처리하기 때문에, 특정 메서드를 호출하는 것으로 모든 작업을 처리할 수 있습니다.



**4) 영구저장소 코디네이터**      
 컨텍스트가 요청한  객체를 데이터가 저장되는 저장소(DB)에서 가져온다. (이 과정은 컨텍스트 객체와 영구 저장소 사이에서 자동으로 처리되기 때문에 직접 구현할 일은 없다고 하네요.)


<br>

### ✐ CoreData의 장단점
#### 장점
- 기기에 데이터를 저장하므로 오프라인에서도 사용할 수 있다.
- First Party 프레임워크라 다른 애플의 프레임워크나  API와 호환성이 좋다.
- 객체 간의 Relation을 다루어주는 객체  그래프 관리자이다.
- SQLite 보다 빠르게 데이터를 가져올 수 있다.


####  단점
- 데이터를 메모리에 로딩하는 과정없이는 사용이 불가능하다. in-memory 방식으로 메모리에 로딩된 객체에 대해서만 수정이 가능하다. (SQLite는 모두 메모리에 로딩하지 않아도 최소한의 데이터만 로드하여 가능)
- Thread safe하지 않다. 멀티 스레드 지원이 안된다. NSManagedObject들과 NSManagedObjectContext의 경우는 싱글스레드에서만 접근되어야 하므로, 만약 다른 스레드가 같은 데이터에 대해 접근해야 한다면 기존 스레드에서 데이터를 저장한 후, 다른 스레드에서 새로운 NSManagedObjectContext를  이용하여  데이터를 읽어야한다.


----------------
<br>

오늘은 코어데이터에 대해서 먼저 살펴보았는데요, 다음 포스팅에서는 코어데이터와 데이터베이스, ORM, UserDefaults 등과 비교해보고 코드로도 작성해보도록 하겠습니다.




<br>
<br>

#### 참고
- 꼼꼼한 재은씨의 Swift - 실전편
- 야곰 아카데미
- [https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreData/index.html#//apple_ref/doc/uid/TP40001075-CH2-SW1](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreData/index.html#//apple_ref/doc/uid/TP40001075-CH2-SW1)
- [https://www.youtube.com/watch?v=6XASUd7h5-s](https://www.youtube.com/watch?v=6XASUd7h5-s)
- [https://www.sunmiya.com/posts/core-data-swift-basic/](https://www.sunmiya.com/posts/core-data-swift-basic/)


<br>
<br>
